# To unbundle, sh this file
echo Makefile 1>&2
sed 's/.//' >Makefile <<'//GO.SYSIN DD Makefile'
-CC = cc
-#CFLAGS = -g -DDEBUG -f68881 #for debugging
-#CFLAGS = -O4 # for sun4
-#CFLAGS = -O -f68881 #for sun3
-CFLAGS = -O3 # Silicon Graphics
-CLIBS = -lm
-OBJECTS = conv.o ctor.o det.o dtor.o edge_maps.o filter.o \
-			find_edges.o  hyst.o loc.o thin.o thld.o write.o
-
-bcd: bcd.o $(OBJECTS)
-	$(CC) -o bcd $(CFLAGS) bcd.o $(OBJECTS) $(CLIBS)
-
-bcd.o: edge_finder.h
-
-cb.o: edge_finder.h
-
-conv.o: edge_finder.h
-
-ctor.o: edge_finder.h
-
-det.o: edge_finder.h
-
-dtor.o: edge_finder.h
-
-edge_maps.o: edge_finder.h
-
-filter.o: edge_finder.h
-
-find_edges.o: edge_finder.h
-
-hyst.o: edge_finder.h
-
-loc.o: edge_finder.h
-
-thin.o: edge_finder.h
-
-thld.o: edge_finder.h
-
-write.o: edge_finder.h
-
-clean:
-	rm *.o
-
-cleanimages:
-	rm det135 det45 detx dety map thin_map hyst_map hi_map gauss
-	
//GO.SYSIN DD Makefile
echo README 1>&2
sed 's/.//' >README <<'//GO.SYSIN DD README'
-/*
- * (c) Copyright 1988 by
- * Robotics Principles Research Department, ATT Bell Laboratories.
- * All rights reserved.
- * Last modified 6/21/88 Ingemar J. Cox
- * Revised 11/11/88 Ingemar J. cox
- */
-                     BOIE-COX EDGE DETECTOR
-
-Two main programs, bc and cb.
-
-bcd -h -t Filter_Width Optional_Threshold < Input_File > Output_File
-
-bcd takes its Input_File from standard input, and writes to standard
-out.
-The option "-h" DISABLES hysteresis thresholding.
-The option "-t" DISABLES thinning
-
-Both the Input_File and the Output_File are in binary form. It is
-assumed that the image is stored row at a time with a 10 byte header
-at the front. The header consists of a two byte type field.
-Followed by nx (two bytes) and ny (two bytes),
-the row and column dimensions. The remaining four bytes are unused.
-********************************************************************
-WARNING: The files bcd.c and write.c should be modified to follow
-the image format used at this site.
-********************************************************************
-
-The edge detector requires the user to provide both the sigma of the
-filter (measured in pixels) and a threshold.
-For most images, 1.5 appears
-to be a commonly used value for sigma.
-
-It is recommended that no threshold be supplied.
-However, the automatic thresholding can be overrided be specifying
-the desired numerical threshold.
-
//GO.SYSIN DD README
echo bcd.c 1>&2
sed 's/.//' >bcd.c <<'//GO.SYSIN DD bcd.c'
-/*
- * (c) Copyright 1988 by
- * Robotics Principles Research Department, ATT Bell Laboratories.
- * All rights reserved.
- * Last modified 2/8/88 Ingemar J. Cox
- * Revised 4/22/88 Ingemar J. Cox
- * Revised 11/11/88 Ingemar J. Cox
- */
-#include <stdio.h>
-#include "edge_finder.h"
-
-#define UBYTE_HD 0x4500
-
-main(argc, argv)
-int argc;
-char *argv[];
-{
-	short header[5];
-	int nx, ny;
-	static unsigned char *pic;
-	float sigma;
-	int threshold;
-	int hysteresis = 1;
-	int thinning = 1;
-	int cnt, i;
-	
-	unsigned char *edge_map;
-	unsigned char *image_find_edges();
-	unsigned char *image_hysteresis();
-	unsigned char *image_thin();
-	float atof();
-	
-	if(argc<2)
-	{
-		fprintf(stderr, "\n***error: wrong number of arguments***\n");
-		fprintf(stderr, 
-			"\n%s -h -t sigma opt_thld < input > output\n", argv[0]);
-		exit(1);
-	}
-	cnt = 1;
-	while(argv[cnt][0]=='-')
-	{
-		switch(argv[cnt][1])
-		{
-			case 'h':
-				hysteresis = 0;
-				cnt++;
-				break;
-			case 't':
-				thinning = 0;
-				cnt++;
-				break;
-			default:
-				fprintf(stderr, "%s: syntax error\n", argv[0]);
-				fprintf(stderr, 
-					"%s -h -t sigma opt_thld < input > output\n", argv[0]);
-				exit(1);
-		}
-	}
-	sigma=atof(argv[cnt++]);
-	if(argc>cnt)
-		threshold=atoi(argv[cnt]);
-	else
-		threshold=0;
-/*
- * now read in image
- */
-	read(0, (char*)header, 10);
-	if(header[0] != UBYTE_HD)
-	{
-		fprintf(stderr, "%s: ERROR image not of unsigned char\n", argv[0]);
-		exit(1);
-	}
-	nx = header[1];
-	ny = header[2];
-	fprintf(stderr, "\nimage size is %d x %d\n", nx, ny);
-	
-	if((pic = (unsigned char *)malloc(nx*ny*sizeof(unsigned char)))==0)
-	{
-		fprintf(stderr, 
-			"%s: ERROR cannot allocate image array\n", argv[0]);
-		exit(1);
-	}
-
-	for(i=0; i<ny; i++)
-	{
-		read(0, (char*)pic+i*nx, nx);
-	}
-	image_init(pic, nx, ny);
-
-	edge_map = image_find_edges(sigma, &threshold);
-	if(hysteresis)
-	{
-		fprintf(stderr, "\napplying hysteresis\n");
-		edge_map = image_hysteresis(threshold/3);
-	}
-	if(thinning)
-	{
-		fprintf(stderr, "\nthinning image\n");
-		edge_map = image_thin();
-	}
-	write(1, (char*)header, 10);
-	write(1, (char*)edge_map, nx*ny);
-
-	image_cleanup();
-}
-
//GO.SYSIN DD bcd.c
echo conv.c 1>&2
sed 's/.//' >conv.c <<'//GO.SYSIN DD conv.c'
-/*
- * (c) Copyright 1988 by
- * Robotics Principles Research Department, ATT Bell Laboratories.
- * All rights reserved.
- * Last modified 2/8/88 Ingemar J. Cox
- * C version 8/2/88 Deborah A. Wallach
- * C version 11/4/88  W.J Kropfl
- */
-#include <stdio.h>
-#include <math.h>
-#include "edge_finder.h"
-
-extern struct image *my_image;
-	static int iklim, nf, nf2;
-	static int iy, ny;
-	static int nxX2M1, ikXnx, nyX2M1Xnx, nfXnx;
-	static int iyMnf2Xnx, iy0, iy0Xnx, it;
-	static int *temp_image, *filter;
-	static unsigned char *tpicP;
-
-void
-image_convolve(pic)
-     unsigned char *pic;
-{
-	register int result, ik, ix, nx;
-	register unsigned char *picP;
-	register int *filtP, *tmpP, *gaussianP;
-
-	nx  = my_image->nx;
-	ny  = my_image->ny;
-	nf  = my_image->nf;	nfXnx = nf*nx;
-	nf2 = my_image->nf2;
-	nxX2M1 = nx + nx - 1;
-	nyX2M1Xnx = (ny + ny - 1)*nx;
-	filter = my_image->filter;
-
-/*
- *	create temp and output arrays
- */
-
-	if((temp_image = (int *)malloc(ny*nx*sizeof(int)))==0)
-	{
-		fprintf(stderr, "error: cannot allocate temp array\n");
-		exit(1);
-	}
-
-	if((my_image->gaussian = (int *)malloc(ny*nx*sizeof(int)))==0)
-	{
-		fprintf(stderr, "error: cannot allocate gaussian array\n");
-		exit(1);
-	}
-/*
- *	first convolve in x-dirn
- *		do left side first
- *		then middle
- *		then right side
- */
-	
-
-	tmpP = &temp_image[0];
-	picP = pic;
-	for(iy=0; iy<ny; iy++, tmpP+=nx, picP+=nx)
-	{
-		for(ix=0; ix<nf2; ix++)
-		{
-			filtP = filter;
-			result = 0;
-			ik = ix - nf2;
-			iklim = ik + nf;
-			for(; ik<iklim; ik++)
-				result += (*filtP++) * picP[abs(ik)];
-
-			*(tmpP+ix) = result;
-		}
-	}
-	
-	tmpP = &temp_image[0];
-	tpicP = pic;
-	for(iy=0; iy<ny; iy++, tmpP+=nx, tpicP+=nx)
-	{
-		int xlim = nx-nf2-1;
-		for(ix=nf2; ix<xlim; ix++)
-		{
-			picP = tpicP+ix-nf2;
-			filtP = filter;
-			result = 0;
-			ik=nf;
-			while(ik--)
-				result += (*filtP++) * (*picP++);
-
-			*(tmpP+ix) = result;
-		}
-	}
-	
-	tmpP = &temp_image[0];
-	picP = pic;
-	for(iy=0; iy<ny; iy++, tmpP+=nx, picP+=nx)
-	{
-		for(ix=nx-nf2-1; ix<nx; ix++)
-		{
-			filtP = filter;
-			result = 0;
-			ik = ix - nf2;
-			iklim = ik + nf;
-			for(; ik<iklim; ik++)
-			{
-	/*			register int index = ix-nf2+ik;
-	 *			if(index>=nx) index = nx+nx-index-1;
-	 *			result += (*filtP++) * picP[index];
-	 */
-				if(ik>=nx)	     /* nxX2M1 = nx+nx-ik-1; */
-					result += *filtP * picP[nxX2M1-ik];
-				else
-					result += *filtP * picP[ik];
-				filtP++;
-			}
-			*(tmpP+ix) = result;
-		}
-	}
-	
-/*
- * then in y-dirn
- *		first top
- *		then middle
- *		then bottom
-*/
-	it = -nf2*nx;
-	for(ix=0; ix<nx; ix++)
-	{
-		gaussianP = &my_image->gaussian[ix];
-		tmpP = &temp_image[ix];
-		iy = 0; iyMnf2Xnx = it;		/* = (iy - nf2)*nx; */
-		for(; iy<nf2; iy++, iyMnf2Xnx+=nx)
-		{
-			filtP = filter;
-			result = 0;
-	/*		ik = iy - nf2;
-	 *		iklim = ik + nf;
-	 *		for(; ik<iklim; ik++)
-	 *			result += (*filtP++) * tmpP[abs(ik)*nx];
-	 */
-			ik = iyMnf2Xnx;
-			iklim = ik + nfXnx;
- 			for(; ik<iklim; ik+=nx)
-				result += (*filtP++) * tmpP[abs(ik)];
-
-	/*		my_image->gaussian[iy*nx+ix] = result/my_image->norm; */
-			*(gaussianP) = result/my_image->norm;
-			gaussianP += nx;
-		}
-	}
-
-	iy0 = nf2;
-	iy0Xnx = iy0 * nx;
-	for(ix=0; ix<nx; ix++)
-	{
-		int *col_tmpP = &temp_image[ix];
-		int ylim = ny-nf2-1;
-		iy = iy0; gaussianP = &my_image->gaussian[iy0Xnx+ix];
-		iyMnf2Xnx = 0;			/* = (iy-nf2)*nx; */
-		for( ; iy<ylim; iy++, iyMnf2Xnx+=nx)
-		{
-			filtP = filter;
-			tmpP = col_tmpP + iyMnf2Xnx;
-			result = 0;
-			ik=nf;
-			while(ik--)
-			{
-				result += (*filtP++) * (*tmpP);
-				tmpP += nx;
-			}
-	/*		my_image->gaussian[iy*nx+ix] = result/my_image->norm; */
-			*(gaussianP) = result/my_image->norm;
-			gaussianP += nx;
-		}
-	}
-
-	iy0 = ny-nf2-1;
-	iy0Xnx = iy0*nx;
-	it = (iy0-nf2)*nx;
-	for(ix=0; ix<nx; ix++)
-	{
-		tmpP = &temp_image[ix];
-		iy = iy0; gaussianP = &my_image->gaussian[iy0Xnx+ix];
-		iyMnf2Xnx = it;			/* = (iy-nf2)*nx; */
-		for( ; iy<ny; iy++, iyMnf2Xnx+=nx)
-		{
-			filtP = filter;
-			result = 0;
-			ik = iy - nf2;
-			iklim = ik + nf;
-			ikXnx = iyMnf2Xnx;
-			for(; ik<iklim; ik++)
-			{
-		/*		register int index = iyMnf2+ik;
-		 *		if(index>=ny) index = ny+ny-index-1;
-		 *		result += (*filtP++) * tmpP[index*nx];
-		*/
-				if(ik>=ny){	 /* nyX2M1Xnx = (ny+ny-1)*nx; */
-				    result += *filtP * tmpP[nyX2M1Xnx-ikXnx];
-				}else
-				    result += *filtP * tmpP[ikXnx];
-				filtP++;
-				ikXnx += nx;
-			}
-	/*		my_image->gaussian[iy*nx+ix] = result/my_image->norm; */
-			*(gaussianP) = result/my_image->norm;
-			gaussianP += nx;
-		}
-	}
-	free(temp_image);
-#ifdef DEBUG
-	image_Write_int("gauss", my_image->gaussian);
-#endif
-}
//GO.SYSIN DD conv.c
echo ctor.c 1>&2
sed 's/.//' >ctor.c <<'//GO.SYSIN DD ctor.c'
-/*
- * (c) Copyright 1988 by
- * Robotics Principles Research Department, ATT Bell Laboratories.
- * All rights reserved.
- * Last modified 2/8/88 Ingemar J. Cox
- * C version 8/2/88 Deborah A. Wallach
- */
-#include <stdio.h>
-#include <math.h>
-#include "edge_finder.h"
-
-struct image *my_image;
-
-image_init(array, xdim, ydim)
-     unsigned char *array;
-     int xdim, ydim;
-{
-    static struct image temp_image;
-
-	temp_image.gaussian = 0;
-	temp_image.filter = 0;
-	temp_image.idx=0;
-	temp_image.idy=0;
-	temp_image.id45=0;
-	temp_image.id135=0;
-	temp_image.edge_map=0;
-	temp_image.an_image = array;
-	temp_image.nx=xdim;
-	temp_image.ny=ydim;
-        my_image = &temp_image;
-  
-}
-
//GO.SYSIN DD ctor.c
echo det.c 1>&2
sed 's/.//' >det.c <<'//GO.SYSIN DD det.c'
-/*
- * (c) Copyright 1988 by
- * Robotics Principles Research Department, ATT Bell Laboratories.
- * All rights reserved.
- * Last modified 2/8/88 Ingemar J. Cox
- * C version 8/2/88 Deborah A. Wallach
- * C version 11/4/88 W. J. Kropfl
- */
-#include <stdio.h>
-#include <math.h>
-#include "edge_finder.h"
-
-extern struct image *my_image;
-
-void
-image_detx()
-{
-	register int *dP, *gP;
-	register int ix, iy;
-	register int nx, ny, nxM1;
-
-	nx = my_image->nx;	nxM1 = nx-1;
-	ny = my_image->ny;
-	
-	if((my_image->idx = (int *)malloc(ny*nx*sizeof(int)))==0)
-	{
-		fprintf(stderr, "error: cannot allocate idx array\n");
-		exit(1);
-	}
-	
-	dP = my_image->idx;
-	gP = my_image->gaussian;
-	for(iy=0; iy<ny; iy++)
-	{
-/*		d[iy*nx] = g[iy*nx] - g[iy*nx+1]; */
-		*dP = *gP - *(gP+1);
-		dP+=nx; gP+=nx;
-	}
-	for(iy=0; iy<ny; iy++)
-	{
-		dP = my_image->idx+iy*nx+1;
-		gP = my_image->gaussian+iy*nx+2;
-		for(ix=1; ix<nxM1; ix++)
-		{
-/*			d[ix] = g[ix+1] - g[ix-1]; */
-			*dP = *gP - *(gP-2);
-			dP++; gP++;
-		}
-	}
-	dP = my_image->idx+nx-1;
-	gP = my_image->gaussian+nx-1;
-	for(iy=0; iy<ny; iy++)
-	{
-/*		d[iy*nx+nx-1] = g[iy*nx+nx-1] - g[iy*nx+nx-2]; */
-		*dP = *gP - *(gP-1);
-		dP+=nx; gP+=nx;
-	}
-#ifdef DEBUG
-	image_Write_int("detx", my_image->idx);
-#endif
-}
-
-void
-image_dety()
-{
-	register int *dP, *gP;
-	register int ix, iy, nx, ny, nyM1, nxPnx;
-
-	nx = my_image->nx;	nxPnx = nx+nx;
-	ny = my_image->ny;	nyM1 = ny-1;
-	
-	if((my_image->idy = (int *)malloc(ny*nx*sizeof(int)))==0)
-	{
-		fprintf(stderr, "error: cannot allocate idy array\n");
-		exit(1);
-	}
-	
-	dP = my_image->idy;
-	gP = my_image->gaussian;
-	for(ix=0; ix<nx; ix++)
-	{
-		dP[ix] = gP[ix] - gP[ix+nx]; 
-/*		*dP = *gP - *(gP+nx);	*/
-/*		dP++; gP++;	*/
-	}
-	for(ix=0; ix<nx; ix++)
-	{
-		dP = my_image->idy+ix;
-		gP = my_image->gaussian+ix;
-		for(iy=1; iy<nyM1; iy++)
-		{
-			dP += nx;
-			*dP = *(gP+nxPnx)- *gP;
-			gP += nx;
-		}
-	}
-	dP = my_image->idy+(ny-1)*nx;
-	gP = my_image->gaussian+(ny-1)*nx;
-	for(ix=0; ix<nx; ix++)
-	{
-		dP[ix] = gP[ix] - gP[ix-nx];
-/*		*dP = *gP - *(gP-nx);	*/
-/*		dP++; gP++; */
-	}
-#ifdef DEBUG
-	image_Write_int("dety", my_image->idy);
-#endif
-}
-void
-image_det45()
-{
-	register int *dP, *gP;
-	register int i, ix, iy, nx,index, ny;
-	register nxP1, nxM1, nyM1;
-
-	nx = my_image->nx;	nxM1 = nx-1;	nxP1 = nx+1;
-	ny = my_image->ny;	nyM1 = ny-1;
-	
-	if((my_image->id45 = (int *)malloc(ny*nx*sizeof(int)))==0)
-	{
-		fprintf(stderr, "error: cannot allocate id45 array\n");
-		exit(1);
-	}
-/*
- *	do top
- *	then middle
- *	then right side
-*/
-	dP = my_image->id45+nx-2;
-	gP = my_image->gaussian+nx-2;
-	for(ix=nx-2; ix>-1; ix--)
-	{
-/*		d[ix] = g[ix] - g[ix+nx+1]; */
-		*dP = *gP - *(gP+nxP1);
-		dP--; gP--;
-	}
-	dP = my_image->id45;
-	gP = my_image->gaussian;
-	for(i=nx-2; i>-1; i--)
-	{
-		ix=i;
-		iy=1;
-		index = nx+ix;
-		while(ix>-1 && iy<nyM1)
-		{
-/*			dP[iy*nx+ix] = gP[(iy+1)*nx+ix-1]-gP[(iy-1)*nx+ix+1]; */
-/*			dP[iy*nx+ix] = gP[iy*nx+ix+nx-1] -gP[iy*nx+ix-nx+1];  */
-			dP[index] = gP[index+nxM1] - gP[index-nxM1];
-			index += nxM1;
-			ix--;
-			iy++;
-		}
-	}
-	for(i=1; i<ny; i++)
-	{
-		ix=nx-2;
-		iy=i;
-		index = iy*nx+ix;
-		while(ix>-1 && iy<nyM1)
-		{
-/*			dP[iy*nx+ix] = gP[(iy+1)*nx+ix-1]-gP[(iy-1)*nx+ix+1]; */
-/*			dP[iy*nx+ix] = gP[iy*nx+ix+nx-1] -gP[iy*nx+ix-nx+1];  */
-			dP[index] = gP[index+nxM1] - gP[index-nxM1];
-			index += nxM1;
-			ix--;
-			iy++;
-		}
-	}
-	dP = my_image->id45+nx+nx-1;
-	gP = my_image->gaussian+nx+nx-1;
-	for(iy=1; iy<ny; iy++)
-	{
-/*		d[iy*nx+nx-1] = g[iy*nx+nx-1] - g[(iy-1)*nx+nx-2]; */
-/*		d[iy*nx+nx-1] = g[iy*nx+nx-1] - g[iy*nx+nx-1-nx-1]; */
-		*dP = *gP - *(gP-nxP1);
-		dP+=nx; gP+=nx;
-	}
-	dP = my_image->id45+(ny-1)*nx;
-	gP = my_image->gaussian+(ny-1)*nx;
-	for(ix=0; ix<nxM1; ix++)
-	{
-/*		dP[(ny-1)*nx+ix] = gP[(ny-1)*nx+ix] - gP[(ny-2)*nx+ix+1];    */
-/*		dP[(ny-1)*nx+ix] = gP[(ny-1)*nx+ix] - gP[(ny-1)*nx+ix-nx+1]; */
-		*dP = *gP - *(gP-nxM1);
-		dP++; gP++;
-	}
-	dP = my_image->id45+(ny-1)*nx;
-	gP = my_image->gaussian+(ny-1)*nx;
-/*	dP[(ny-1)*nx+nx-1] = gP[(ny-1)*nx+nx-1] - gP[(ny-2)*nx+nx-2];      */
-/*	dP[(ny-1)*nx+nx-1] = gP[(ny-1)*nx+nx-1] - gP[(ny-1)*nx+nx-1-nx-1]; */
-	dP[nxM1] = gP[nxM1] - gP[-2];
-	dP = my_image->id45;
-	gP = my_image->gaussian;
-	dP[nxM1] = gP[nxM1]-gP[nx+nx-2];
-#ifdef DEBUG
-	image_Write_int("det45", my_image->id45);
-#endif
-}
-
-void
-image_det135()
-{
-	register int *dP, *gP;
-	register int i, ix, iy, nx,index, ny;
-	register nxP1, nxM1, nyM1, nxM2;
-
-	nx = my_image->nx;	nxM1 = nx-1;	nxP1 = nx+1;	nxM2 = nx-2;
-	ny = my_image->ny;	nyM1 = ny-1;
-	
-	if((my_image->id135 = (int *)malloc(ny*nx*sizeof(int)))==0)
-	{
-		fprintf(stderr, "error: cannot allocate id135 array\n");
-		exit(1);
-	}
-/*
- *	do top
- *	then middle
- *	then right side
-*/
-	dP = my_image->id135+1;
-	gP = my_image->gaussian+1;
-	for(ix=1; ix<nx; ix++)
-	{
-/*		d[ix] = g[ix] - g[ix+nx-1]; */
-		*dP = *gP - *(gP+nxM1);
-		dP++; gP++;
-	}
-	dP = my_image->id135;
-	gP = my_image->gaussian;
-	for(i=1; i<nxM1; i++)
-	{
-		ix=i;
-		iy=1;
-		index = nx+ix;
-		while(ix<nxM1 && iy<nyM1)
-		{
-/*			dP[iy*nx+ix] = gP[(iy+1)*nx+ix+1]-gP[(iy-1)*nx+ix-1];*/
-/*			dP[iy*nx+ix] = gP[iy*nx+ix+nx+1]-gP[iy*nx+ix-nx-1];  */
-			dP[index] = gP[index+nxP1] - gP[index-nxP1];
-			index += nxP1;
-			ix++;
-			iy++;
-		}
-	}
-	for(i=1; i<ny; i++)
-	{
-		ix=1;
-		iy=i;
-		index = iy*nx+ix;
-		while(ix<nxM1 && iy<nyM1)
-		{
-/*			dP[iy*nx+ix] = gP[(iy+1)*nx+ix+1]- gP[(iy-1)*nx+ix-1];*/
-/*			dP[iy*nx+ix] = gP[iy*nx+ix+nx+1] - gP[iy*nx+ix-nx-1]; */
-			dP[index] = gP[index+nxP1] - gP[index-nxP1];
-			index += nxP1;
-			ix++;
-			iy++;
-		}
-	}
-	dP = my_image->id135+nx;
-	gP = my_image->gaussian+nx;
-	for(iy=1; iy<ny; iy++)
-	{
-/*		d[iy*nx] = g[iy*nx] - g[(iy-1)*nx+2]; */
-/*		d[iy*nx] = g[iy*nx] - g[iy*nx-nx+2]; */
-		*dP = *gP - *(gP-nxM2);
-		dP+=nx; gP+=nx;
-	}
-	dP = my_image->id135+nx+nx-1;
-	gP = my_image->gaussian+nx+nx-1;
-	for(iy=1; iy<ny; iy++)
-	{
-/*		d[iy*nx+nx-1] = g[iy*nx+nx-1] - g[(iy-1)*nx+nx-2];  */
-/*		d[iy*nx+nx-1] = g[iy*nx+nx-1] - g[iy*nx+nx-1-nx-1]; */
-		*dP = *gP - *(gP-nxP1);
-		dP+=nx; gP+=nx;
-	}
-
-	dP = my_image->id135+(ny-1)*nx+1;
-	gP = my_image->gaussian+(ny-1)*nx+1;
-	for(ix=1; ix<nxM1; ix++)
-	{
-/*		d[(ny-1)*nx+ix] = g[(ny-1)*nx+ix] - g[(ny-2)*nx+ix-1];    */
-/*		d[(ny-1)*nx+ix] = g[(ny-1)*nx+ix] - g[(ny-1)*nx+ix-nx-1]; */
-		*dP = *gP - *(gP-nxP1);
-		dP++; gP++;
-	}
-	dP = my_image->id135;
-	gP = my_image->gaussian;
-	dP[nxM1] = gP[nxM1] - gP[nx+nx-2];
-	dP[0] = gP[0] - gP[nx+1];
-#ifdef DEBUG
-	image_Write_int("det135", my_image->id135);
-#endif
-}
//GO.SYSIN DD det.c
echo dtor.c 1>&2
sed 's/.//' >dtor.c <<'//GO.SYSIN DD dtor.c'
-/*
- * (c) Copyright 1988 by
- * Robotics Principles Research Department, ATT Bell Laboratories.
- * All rights reserved.
- * Last modified 2/8/88 Ingemar J. Cox
- * C version 8/2/88 Deborah A. Wallach
- */
-#include <stdio.h>
-#include <math.h>
-#include "edge_finder.h"
-
-extern struct image *my_image;
-
-image_cleanup()
-{
-    free(my_image->gaussian);
-    free(my_image->filter);
-    free(my_image->idx);
-    free(my_image->idy);
-    free(my_image->id45);
-    free(my_image->id135);
-    free(my_image->edge_map_hi);
-}
-
//GO.SYSIN DD dtor.c
echo edge_finder.h 1>&2
sed 's/.//' >edge_finder.h <<'//GO.SYSIN DD edge_finder.h'
-/*
- * (c) Copyright 1988 by
- * Robotics Principles Research Department, ATT Bell Laboratories.
- * All rights reserved.
- * Last modified 2/8/88 Ingemar J. Cox
- * C version 8/2/88 Deborah A. Wallach
- */
-
-#define abs(x) ((x)<0 ? -(x) : (x))
-#define max(x, y) ((x)>(y) ? (x) : (y))
-#define min(x, y) ((x)<(y) ? (x) : (y))
-
-#define EDGE_X 1
-#define EDGE_Y 2
-#define EDGE_45 3
-#define EDGE_135 4
-
-#define FWD 0
-#define BWD 1
-
-#define diag_scale 1.414 /* scale factor for diagonals */
-
-struct image
-{
-	unsigned char *an_image; /* pointer to image array */
-	int nx, ny; /* dimensions of image array */
-
-	int*	gaussian; /* pointer to output image after convolution */
-	int *idx, *idy, *id45, *id135; /* pointers to o/p from detn filters */
-
-	int *filter; /* pointer to 1D array of filter coefficients */
-	int norm; /* normalization factor after convolution */
-	int nf, nf2; /* nf = size of filter (in pixels), nf2=nf/2 */
-	int orient_flag;
-	unsigned char *edge_map, *edge_map_hi;
-	int lo_threshold;
-};
-
-
-
//GO.SYSIN DD edge_finder.h
echo edge_maps.c 1>&2
sed 's/.//' >edge_maps.c <<'//GO.SYSIN DD edge_maps.c'
-/*
- * (c) Copyright 1988 by
- * Robotics Principles Research Department, ATT Bell Laboratories.
- * All rights reserved.
- * Last modified 2/8/88 Ingemar J. Cox
- * C version 8/2/88 Deborah A. Wallach
- * C version 11/2/88 W. J. Kropfl
- */
-#include <stdio.h>
-#include <math.h>
-#include "edge_finder.h"
-
-extern struct image *my_image;
-extern int nxXny;		/*???*/
-
-#define _nx my_image->nx
-#define image_zc_x(ix,iy,i) \
-(((image_locx(iy,ix,i)>0) != (image_locx(iy,ix+1,i+1)>0)) ?EDGE_X:0)
-
-#define image_zc_y(ix,iy,i) \
-(((image_locy(iy+1,ix,i+_nx)>0) != (image_locy(iy,ix,i)>0)) ?EDGE_Y:0)
-
-#define image_zc_135(ix,iy,i) \
-(((image_loc135(iy+1,ix+1,i+_nx+1)>0) != (image_loc135(iy,ix,i)>0)) ?EDGE_135:0)
-
-#define image_zc_45(ix,iy,i) \
-(((image_loc45(iy+1,ix-1,i+_nx-1)>0) != (image_loc45(iy,ix,i)>0)) ?EDGE_45:0)
-
-unsigned char* image_edges(threshold)
-     int threshold;
-{
-	unsigned char *map;
-	register int ix, iy, nx, orient_flag, index, ny;
-
-	register int *px = my_image->idx;
-	register int *py = my_image->idy;
-	register int *p45  = my_image->id45;
-	register int *p135 = my_image->id135;
-	register unsigned char *mapp;
-
-	nx = my_image->nx;
-	ny = my_image->ny;
-	nxXny = nx*ny;
-
-	if((map = (unsigned char *)malloc(ny*nx*sizeof(unsigned char)))==0)
-	{
-		fprintf(stderr, "error: cannot allocate map array\n");
-		exit(1);
-	}
-	mapp = map;	
-
-	for(iy=0; iy<ny; iy++)
-	{
-		for(ix=0; ix<nx; ix++)
-		{
-			register int sx, sy, s45, s135;
-			register int big;
-			sx = abs(*px);  px++;
-			sy = abs(*py); 	py++;
-			s45 = (int)((float)(abs(*p45))/diag_scale); p45++;
-			s135 = (int)((float)(abs(*p135))/diag_scale); p135++;
-
-			big = sx;
-
-			orient_flag = EDGE_X;
-
-			if(sy>big)
-			{
-				big=sy;
-				orient_flag = EDGE_Y;
-			}
-			if(s45>big)
-			{
-				big=s45;
-				orient_flag = EDGE_45;
-			}
-			if(s135>big)
-			{
-				big=s135;
-				orient_flag = EDGE_135;
-			}
-
-			my_image->orient_flag = orient_flag; 
-
-			if(big > threshold)
-			{
-				index = mapp - map;
-				switch (orient_flag)
-				{
-				   case EDGE_X:
-					*mapp++ = image_zc_x(ix, iy, index);
-					break;
-				   case EDGE_Y:
-					*mapp++ = image_zc_y(ix, iy, index);
-					break;
-				   case EDGE_45:
-					*mapp++ = image_zc_45(ix, iy, index);
-					break;
-				   case EDGE_135:
-					*mapp++ = image_zc_135(ix, iy, index);
-					break;
-				   default:
-					fprintf(stderr, "error in case statements\n");
-					exit(1);
-					break;
-				}
-			}
-			else
-			{
-				*mapp++ = 0;
-			}
-		    }
-	}
-#ifdef DEBUG
-	image_Write_char("hi_map", map);
-#endif
-	return(map);
-}
-
-image_edge_map_lo(ix, iy, index)
-register int ix, iy, index;		/* index = iy*nx+ix; */
-{
-	register int big, sx, sy, s45, s135;
-
-	sx = abs(my_image->idx[index]);
-	sy = abs(my_image->idy[index]);
-	s45  = (int)((float)(abs(my_image->id45[index]))/diag_scale);
-	s135 = (int)((float)(abs(my_image->id135[index]))/diag_scale);
-	big=sx;
-
-	my_image->orient_flag = EDGE_X;
-	
-	if(sy>big)
-	{
-		big=sy;
-		my_image->orient_flag = EDGE_Y;
-	}
-	if(s45>big)
-	{
-		big=s45;
-		my_image->orient_flag = EDGE_45;
-	}
-	if(s135>big)
-	{
-		big=s135;
-		my_image->orient_flag = EDGE_135;
-	}
-
-	if(big > my_image->lo_threshold)
-	{
-		switch (my_image->orient_flag)
-		{
-			case EDGE_X:
-				return(image_zc_x(ix, iy, index));
-			case EDGE_Y:
-				return(image_zc_y(ix, iy, index));
-			case EDGE_45:
-				return(image_zc_45(ix, iy, index));
-			case EDGE_135:
-				return(image_zc_135(ix, iy, index));
-			default:
-				fprintf(stderr, "error in case statements\n");
-				exit(1);
-				break;
-		}
-	}
-	else
-		return(0);
-}
//GO.SYSIN DD edge_maps.c
echo filter.c 1>&2
sed 's/.//' >filter.c <<'//GO.SYSIN DD filter.c'
-/*
- * (c) Copyright 1988 by
- * Robotics Principles Research Department, ATT Bell Laboratories.
- * All rights reserved.
- * Last modified 2/8/88 Ingemar J. Cox
- * C version 8/2/88 Deborah A. Wallach
- */
-#include <stdio.h>
-#include <math.h>
-#include "edge_finder.h"
-
-extern struct image *my_image;
-
-void generate_filter(sigma)
-     float sigma;
-{
-	int i;
-	float two_sigma_sq;
-
-	my_image->nf = (int)(3*2*sigma);
-	my_image->nf = (my_image->nf%2>0?my_image->nf:my_image->nf+1);
-	my_image->nf2 =	my_image->nf/2;
-	
-	if((my_image->filter = (int *)malloc(my_image->nf*sizeof(int)))==0)
-	{
-		fprintf(stderr, "error: cannot allocate filter array\n");
-		exit(1);
-	}
-	two_sigma_sq = 2.0*sigma*sigma;
-	my_image->norm=0;
-	for(i=0;i<my_image->nf;i++)
-	{
-		float x = i-my_image->nf2;
-		my_image->filter[i] = (int)(255.0*exp(-x*x/two_sigma_sq));
-		my_image->norm += my_image->filter[i];
-	}
-	my_image->norm=abs(my_image->norm);
-#ifdef DEBUG
-	fprintf(stderr, "filter length = %d\n", my_image->nf);
-	for(i=0;i<my_image->nf;i++)
-		fprintf(stderr,"f[%d] = %d\n", i, my_image->filter[i]);
-#endif
-}
//GO.SYSIN DD filter.c
echo find_edges.c 1>&2
sed 's/.//' >find_edges.c <<'//GO.SYSIN DD find_edges.c'
-/*
- * (c) Copyright 1988 by
- * Robotics Principles Research Department, ATT Bell Laboratories.
- * All rights reserved.
- * Last modified 2/8/88 Ingemar J. Cox
- * C version 8/2/88 Deborah A. Wallach
- * Automatic thresholding 9/30/88 Ingemar J. Cox
- */
-#include <stdio.h>
-#include <math.h>
-#include "edge_finder.h"
-
-extern struct image *my_image;
-
-unsigned char*
-image_find_edges(sigma, threshold)
-     float sigma;
-     int *threshold;
-{
-    unsigned char *image_edges();
-
-	fprintf(stderr, "\ngenerating filter sigma = %.1f", sigma);
-	generate_filter(sigma);
-	fprintf(stderr, " ( length = %d)\n", my_image->nf);
-
-	fprintf(stderr, "\nconvolving image\n");
-	image_convolve(my_image->an_image);
-
-	fprintf(stderr, "\ngenerating detx\n");
-	image_detx();
-
-	fprintf(stderr, "\ngenerating dety\n");
-	image_dety();
-
-	fprintf(stderr, "\ngenerating det45\n");
-	image_det45();
-
-	fprintf(stderr, "\ngenerating det135\n");
-	image_det135();
-
-	if(*threshold==0)
-	{
-		fprintf(stderr, "\nestimating threshold\n");
-		*threshold=image_threshold();
-	}
-	fprintf(stderr, "\ngenerating edge_map (threshold = %d)\n",
-		*threshold);
-	my_image->edge_map = image_edges(*threshold);
-
-	return(my_image->edge_map);
-}
-
//GO.SYSIN DD find_edges.c
echo hyst.c 1>&2
sed 's/.//' >hyst.c <<'//GO.SYSIN DD hyst.c'
-/*
- * (c) Copyright 1988 by
- * Robotics Principles Research Department, AT&T Bell Laboratories.
- * All rights reserved.
- * Last modified 2/8/88 Ingemar J. Cox
- * C version 8/2/88 Deborah A. Wallach
- * C version 11/4/88 W. K. Kropfl
- */
-#include <stdio.h>
-#include <math.h>
-#include "edge_finder.h"
-
-extern struct image *my_image;
-void image_neighbor_fwd();
-void image_neighbor_bwd();
-
-static nx, ny;
-int  nxXny;
-
-unsigned char* image_hysteresis(lo_thld)
-     int lo_thld;
-{
-	register int iy, ix;
-	register unsigned char *lmapP, *lmap_hiP, *mapP;
-	
-	nx = my_image->nx;
-	ny = my_image->ny;
-	nxXny = nx*ny;
-	my_image->lo_threshold = lo_thld;
-	my_image->edge_map_hi = my_image->edge_map;
-	my_image->edge_map = (unsigned char *)malloc(nx*ny*sizeof(unsigned char));
-
-	lmap_hiP = &my_image->edge_map_hi[0];
-	lmapP    = &my_image->edge_map[0];
-
-	mapP = lmapP;
-	for(ix=nx*ny; --ix>=0; )
-		*mapP++ = 0;
-
-	for(iy=0; iy<ny; iy++, lmap_hiP+=nx, lmapP+=nx)
-	{
-		mapP = lmapP;
-		for(ix=0; ix<nx; ix++, mapP++)
-		{
-			if(lmap_hiP[ix] != 0)
-			{
-				*mapP = lmap_hiP[ix];
-				image_neighbor_fwd(iy, ix, mapP);
-				image_neighbor_bwd(iy, ix, mapP);
-			}
-		}
-	}
-	return(my_image->edge_map);
-}
-
-void image_neighbor_fwd(iy, ix, mapP)
-register int iy, ix;
-register unsigned char *mapP;
-{
-	switch(*mapP)
-	{
-		case 5:
-			return;
-
-		case EDGE_Y: /*0*/
-			if(!Fcontour(iy,ix+1)&&Fcontour(iy,ix+2))
-				goto L_EDGE_Y;
-			else if(!(Fcontour(iy-1,ix+1)||Fcontour(iy+1,ix+1))&&
-				(Fcontour(iy-1,ix+2)||Fcontour(iy+1,ix+2)))
-			{
-	L_EDGE_Y:		if(ix+1<nx) *(mapP+1) = 5;
-			}
-			break;
-		case EDGE_135: /*45*/
-			if(!Fcontour(iy-1,ix+1)&&Fcontour(iy-2,ix+2))
-				goto L_EDGE_135;
-			else if(!(Fcontour(iy,ix+1)||Fcontour(iy-1,ix))&&
-				(Fcontour(iy-2,ix+1)||Fcontour(iy-1, ix+2)))
-			{
-	L_EDGE_135:		if((iy-1>=0)&&(ix+1<nx)) *(mapP-nx+1) = 5;
-			}
-			break;
-		case EDGE_X: /*90*/
-			if(!Fcontour(iy-1, ix)&&Fcontour(iy-2, ix))
-				goto L_EDGE_X;
-			else if(!(Fcontour(iy-1, ix-1)||Fcontour(iy-1, ix+1))&&
-				(Fcontour(iy-2, ix-1)||Fcontour(iy-2,ix+1)))
-			{
-	L_EDGE_X:		if(iy-1>=0) *(mapP-nx) = 5;
-			}
-			break;
-		case EDGE_45: /*135*/
-			if(!Fcontour(iy+1, ix+1)&&Fcontour(iy+2,ix+2))
-				goto L_EDGE_45;
-			else if(!(Fcontour(iy,ix+1)||Fcontour(iy+1,ix))&&
-				(Fcontour(iy+1,ix+2)||Fcontour(iy+2,ix+1)))
-			{
-	L_EDGE_45:		if((iy+1<ny)&&(ix+1<nx)) *(mapP+nx+1) = 5;
-			}
-			break;
-		default:
-			fprintf(stderr, "error in case statements\n");
-			fprintf(stderr, "x=%d y=%d\n",ix, iy);
-			exit(1);
-			break;
-	}
-}
-
-void image_neighbor_bwd(iy, ix, mapP)
-register int iy, ix;
-register unsigned char *mapP;
-{
-	switch(*mapP)
-	{
-		case  5:
-			return;
-
-		case EDGE_Y: /*0*/
-			if(!Bcontour(iy,ix-1)&&Bcontour(iy,ix-2))
-				goto L_EDGE_Y;
-			else if(!(Bcontour(iy-1,ix-1)||Bcontour(iy+1,ix-1))&&
-				(Bcontour(iy-1,ix-2)||Bcontour(iy+1,ix-2)))
-			{
-	L_EDGE_Y:		if(ix-1>=0) *(mapP-1) = 5;
-			}
-			break;
-		case EDGE_135: /*45*/
-			if(!Bcontour(iy+1,ix-1)&&Bcontour(iy+2,ix-2))
-				goto L_EDGE_135;
-			else if(!(Bcontour(iy,ix-1)||Bcontour(iy+1,ix))&&
-				(Bcontour(iy+1,ix-2)||Bcontour(iy+2,ix-1)))
-			{
-	L_EDGE_135:		if((iy+1<ny)&&(ix-1>=0)) *(mapP+nx-1) = 5;
-			}
-			break;
-		case EDGE_X: /*90*/
-			if(!Bcontour(iy+1, ix)&&Bcontour(iy+2, ix))
-				goto L_EDGE_X;
-			else if(!(Bcontour(iy+1,ix-1)||Bcontour(iy+1,ix+1))&&
-				(Bcontour(iy+2,ix-1)||Bcontour(iy+2,ix+1)))
-			{
-	L_EDGE_X:		if(iy+1<ny) *(mapP+nx) = 5;
-			}
-			break;
-		case EDGE_45: /*135*/
-			if(!Bcontour(iy-1, ix-1)&&Bcontour(iy-2,ix-2))
-				goto L_EDGE_45;
-			else if(!(Bcontour(iy,ix-1)||Bcontour(iy-1,ix))&&
-				(Bcontour(iy-1,ix-2)||Bcontour(iy-2,ix-1)))
-			{
-	L_EDGE_45:		if((iy-1>=0)&&(ix-1>=0)) *(mapP-nx-1) = 5;
-			}
-			break;
-		default:
-			fprintf(stderr, "error in case statements\n");
-			fprintf(stderr, "x=%d y=%d\n",ix, iy);
-			exit(1);
-			break;
-	}
-}
-
-int Fcontour(iy, ix)
-register int iy, ix;
-{
-	int edge_pt, index;
-	register unsigned char *mapP;
-
-	/*if(ix<0||ix>=nx||iy<0||iy>=ny) return(0);*/
-
-	index =iy*nx+ix;
-	if(index<0 || index>=nxXny)
-		return(0);
-
-	mapP = &my_image->edge_map[index];
-	if(*mapP > 0)
-		return(1);
-	else if((edge_pt=image_edge_map_lo(ix, iy, index)) != 0)
-	{
-		*mapP = edge_pt;
-		image_neighbor_fwd(iy, ix, mapP);
-		return(1);
-	} else
-		return(0);
-}
-
-int Bcontour(iy, ix)
-register int iy, ix;
-{
-	register unsigned char *mapP;
-	int edge_pt, index;
-
-	/*if(ix<0||ix>=nx||iy<0||iy>=ny) return(0);*/
-
-	index =iy*nx+ix;
-	if(index<0 || index>=nxXny)
-		return(0);
-
-	mapP = &my_image->edge_map[index];
-	if(*mapP > 0)
-		return(1);
-	else if((edge_pt=image_edge_map_lo(ix, iy, index)) != 0)
-	{
-		*mapP = edge_pt;
-		image_neighbor_bwd(iy, ix, mapP);
-		return(1);
-	} else
-		return(0);
-}
//GO.SYSIN DD hyst.c
echo loc.c 1>&2
sed 's/.//' >loc.c <<'//GO.SYSIN DD loc.c'
-/*
- * (c) Copyright 1988 by
- * Robotics Principles Research Department, ATT Bell Laboratories.
- * All rights reserved.
- * Last modified 2/8/88 Ingemar J. Cox
- * C version 8/2/88 Deborah A. Wallach
- * C version 11/4/88 W, J Kropfl
- */
-#include <stdio.h>
-#include <math.h>
-#include "edge_finder.h"
-
-extern struct image *my_image;
-extern int nxXny;
-
-int image_locx(iy, ix, index)
-register int ix, iy, index;		/* index = iy*nx+ix */
-{
-	register int *imP;
-	register int nx = my_image->nx; 
-
-/*	if(index<=0 || index>=nxXny) */
-	if(ix<2 || ix>nx-2 || iy<0 || iy>my_image->ny-1)
-		return(0);
-
-/*	return(gauss[iy*nx+x-1]+gauss[iy*nx+ix+1]-2*gauss[iy*nx+ix]);*/
-
-/*	return(idx[iy*nx+ix] - idx[iy*nx+ix-1]); */
-	imP = &my_image->idx[index];
-	return(*imP - *(imP-1));
-}
-
-int image_locy(iy, ix, index)
-register int ix, iy, index;		/* index = iy*nx+ix */
-{
-	register int *imP;
-	register int nx = my_image->nx;
-
-/*	if(index<nx || index>=nxXny) */
-	if(ix<0 || ix>nx-1 || iy<2 || iy>my_image->ny-2)
-		return(0);
-
-/*	return(gauss[(iy-1)*nx+ix]+gauss[(iy+1)*nx+ix]-2*gauss[iy*nx+ix]);*/
-
-/*	return(idy[iy*nx+ix] - idy[(iy-1)*nx+ix]); */
-	imP = &my_image->idy[index];
-	return(*imP - *(imP-nx));
-}
-
-int image_loc45(iy, ix, index)
-register int ix, iy, index;		/* index = iy*nx+ix */
-{
-	register int *imP;
-	register int nx = my_image->nx;
-
-/*	if(index<nx || index>=nxXny) */
-	if(ix<2 || ix>nx-2 || iy<2 || iy>my_image->ny-2)
-		return(0);
-
-/*	return(gauss[(iy-1)*nx+ix+1]+gauss[(iy+1)*nx+ix-1]-2*gauss[iy*nx+ix]);*/
-
-/*	return(id45[iy*nx+ix] - id45[(iy-1)*nx+ix+1]); */
-	imP = &my_image->id45[index];
-	return(*imP - *(imP-nx+1));
-}
-
-int image_loc135(iy, ix, index)
-register int ix, iy, index;		/* index = iy*nx+ix */
-{
-	register int *imP;
-	register int nx = my_image->nx;
-
-/*	if(index<=nx || index>=nxXny) */
-	if(ix<2 || ix>nx-2 || iy<2 || iy>my_image->ny-2)
-		return(0);
-
-/*	return(gauss[(iy-1)*nx+ix-1]+gauss[(iy+1)*nx+ix+1]-2*gauss[iy*nx+ix]);*/
-
-/*	return(id135[iy*nx+ix] - id135[(iy-1)*nx+ix-1]);*/
-	imP = &my_image->id135[index];
-	return(*imP - *(imP-nx-1));
-}
-
//GO.SYSIN DD loc.c
echo thin.c 1>&2
sed 's/.//' >thin.c <<'//GO.SYSIN DD thin.c'
-/*
- * (c) Copyright 1988 by
- * Robotics Principles Research Department, ATT Bell Laboratories.
- * All rights reserved.
- * Last modified 2/8/88 Ingemar J. Cox
- *
- *	Original thinning code (in LISP) courtesy of J. F. Canny
- *	Converted to C++ 1/15/88, Ingemar J. Cox
- *	C version 8/2/88 Deborah A. Wallach
- *	C version 11/4/88 W. J. Kropfl 
- */
-
-#include <stdio.h>
-#include <math.h>
-#include "edge_finder.h"
-
-extern struct image *my_image;
-
-unsigned char* image_thin()
-{
-	register unsigned char *emP, *emPiy;
-	register int ix, nx, nxM1, nxP1;
-	register int iy, nlinks, npieces;
-	register int ny, nyM1;
-
-	register int b01, b12, b21, b10;
-	register int p1, p2, p3, p4;
-	register int b00, b02, b20, b22;
-	
-	nx   = my_image->nx;
-	nxM1 = nx - 1;
-	nxP1 = nx + 1;
-	nyM1 = my_image->ny - 1;
-
-	emPiy = &my_image->edge_map[0];
-	for(iy=1; iy<nyM1; iy++)
-	{
-		emPiy += nx;
-		for(ix=1; ix<nxM1; ix++)
-		{
-			emP = emPiy + ix;
-			b01 = *(emP-nx)>0;
-			b12 = *(emP+1)>0;
-			b21 = *(emP+nx)>0;
-			b10 = *(emP-1)>0;
-			if((b01+b12+b21+b10)>1)
-			{
-				b00 = *(emP-nxP1)>0;
-				b02 = *(emP-nxM1)>0;
-				b20 = *(emP+nxM1)>0;
-				b22 = *(emP+nxP1)>0;
-				
-				p1 = b00 | b01;
-				p2 = b02 | b12;
-				p3 = b22 | b21;
-				p4 = b20 | b10;
-				
-				nlinks  = b01 & p2;
-				nlinks += b12 & p3;
-				nlinks += b21 & p4;
-				nlinks += b10 & p1;
-				
-				npieces = p1 + p2 + p3 + p4;
-				
-				if((npieces-nlinks)<2)
-					*emP = 0;   /*edge_map[iy*nx+ix]=0; */
-			}
-		}
-	}
-	return(my_image->edge_map);
-}
-
//GO.SYSIN DD thin.c
echo thld.c 1>&2
sed 's/.//' >thld.c <<'//GO.SYSIN DD thld.c'
-/*
- * (c) Copyright 1988 by
- * Robotics Principles Research Department, ATT Bell Laboratories.
- * All rights reserved.
- * Last modified 2/8/88 Ingemar J. Cox
- * C version 8/2/88 Deborah A. Wallach
- * Automatic thresholding 9/30/88 Ingemar J. Cox
- */
-
-#include <stdio.h>
-#include "edge_finder.h"
-
-extern struct image *my_image;
-
-int image_threshold()
-{
-	int ix, iy, nx, ny;
-	int *detx, tmp;
-	float mad = 0; /* calculate mean absolute deviation */
-
-	detx=my_image->idx;
-	nx = my_image->nx;
-	ny = my_image->ny;
-
-	for(iy=0;iy<ny;iy++)
-	{
-		for(ix=0;ix<nx;ix++)
-		{
-			tmp = *detx++;
-			mad += abs(tmp);
-		}
-	}
-	return((int)((float)(3*mad/nx/ny)/0.8));
-}
-
//GO.SYSIN DD thld.c
echo write.c 1>&2
sed 's/.//' >write.c <<'//GO.SYSIN DD write.c'
-
-/*
- * (c) Copyright 1988 by
- * Robotics Principles Research Department, ATT Bell Laboratories.
- * All rights reserved.
- * Last modified 2/8/88 Ingemar J. Cox
- * C version 8/2/88 Deborah A. Wallach
- */
-#include <stdio.h>
-#include <math.h>
-#include "edge_finder.h"
-
-extern struct image *my_image;
-
-void
-image_Write_int(name, pointer)
-     char *name;
-     int *pointer;
-{
-	short header[5];
-	int fd;
-
-	header[0]=0x4513;
-	header[1]=my_image->nx;
-	header[2]=my_image->ny;
-	header[3]=header[4]=0;
-	fd = creat(name, 0666);
-	write(fd, (char*)header, 10);
-	write(fd, (char*)pointer, my_image->nx*my_image->ny*4);
-	close(fd);
-}
-
-void
-image_Write_char(name, pointer)
-     char *name;
-     unsigned char *pointer;
-{
-	short header[5];
-	int fd;
-
-	header[0]=0x4500;
-	header[1]=my_image->nx;
-	header[2]=my_image->ny;
-	header[3]=header[4]=0;
-	fd = creat(name, 0666);
-	write(fd, (char*)header, 10);
-	write(fd, (char*)pointer, my_image->nx*my_image->ny);
-	close(fd);
-}
-
//GO.SYSIN DD write.c

